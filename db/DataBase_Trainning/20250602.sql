--저장 프로시저 함수로 생각 할 것
CREATE OR REPLACE PROCEDURE EMP_PROCEDURE
IS
    -- 임의 문자를 받는 변수
    VWORD VARCHAR2(1);
    -- 모든 레코드 타입을 받는 변수
    VEMP EMPLOYEES%ROWTYPE;
    -- 커서 = ARRAYLIST
    CURSOR C1 (VWORD VARCHAR2)
    IS
    SELECT EMPLOYEE_ID,FIRST_NAME,SALARY,JOB_ID FROM EMPLOYEES WHERE FIRST_NAME LIKE '%'||VWORD||'%';
BEGIN
    --임의문자 추출하고,출력
    VWORD := DBMS_RANDOM.STRING('a',1);
    DBMS_OUTPUT.PUT_LINE('랜덤 문자'||VWORD);
    OPEN C1(VWORD);
    LOOP
        FETCH C1 INTO VEMP.EMPLOYEE_ID,VEMP.FIRST_NAME,VEMP.SALARY,VEMP.JOB_ID;
        -- C1 ROWCOUNT
        IF C1%ROWCOUNT = 0 THEN
            DBMS_OUTPUT.PUT_LINE('해당되는 직원이 없습니다.');
        END IF;
        EXIT WHEN C1%NOTFOUND;
        DBMS_OUTPUT.PUT_LINE('ID = '||VEMP.EMPLOYEE_ID||'FIRST_NAME = '||VEMP.FIRST_NAME||'SALARY = '||VEMP.SALARY);
    END LOOP;
END;
/
SHOW ERROR;

EXECUTE EMP_PROCEDURE;

--PROCEDURE 소스 추출.
SELECT * FROM USER_SOURCE;

--매개변수가 있는 PROCEDURE
CREATE OR REPLACE PROCEDURE EMP_PROCEDURE2(VWORD IN VARCHAR2)
IS
    VCOUNT NUMBER := 0;
    -- 모든 레코드 타입을 받는 변수
    VEMP EMPLOYEES%ROWTYPE;
    -- 커서 = ARRAYLIST 
    CURSOR C1
    IS
    SELECT EMPLOYEE_ID,FIRST_NAME FROM EMPLOYEES WHERE FIRST_NAME LIKE '%'||VWORD||'%';
BEGIN
    DBMS_OUTPUT.PUT_LINE('입력된 문자'|| VWORD);
    FOR VEMP IN C1 LOOP
        IF C1%NOTFOUND = TRUE THEN
           DBMS_OUTPUT.PUT_LINE('데이터 X');
           EXIT;
        END IF;
        DBMS_OUTPUT.PUT_LINE('ID = '||VEMP.EMPLOYEE_ID||'FIRST_NAME = '||VEMP.FIRST_NAME);
    END LOOP;
END;
/
SHOW ERROR;

EXECUTE EMP_PROCEDURE2('1');
--민우꺼
CREATE OR REPLACE PROCEDURE EMP_PROCEDURE2(VWORD IN VARCHAR2)
IS
    FLAG BOOLEAN := FALSE;
   -- 모든 레코드 타입을 받는 변수
   VEMP EMPLOYEES%ROWTYPE;
   -- 커서 = ARRAY LIST
   CURSOR C1
   IS
   SELECT EMPLOYEE_ID, FIRST_NAME FROM EMPLOYEES WHERE FIRST_NAME LIKE '%'||VWORD||'%';
BEGIN
    DBMS_OUTPUT.PUT_LINE('입력된 문자 = '||VWORD);
      FOR VEMP IN C1 LOOP
        FLAG := TRUE;
         DBMS_OUTPUT.PUT_LINE('ID='||VEMP.EMPLOYEE_ID||'FIRST_NAME='||VEMP.FIRST_NAME);
      END LOOP;
      
      IF FLAG = FALSE THEN
        DBMS_OUTPUT.PUT_LINE('해당사원이 없다.');
   END IF;
END;
/
-- DEPT01 새로운 부서를 프로시저를 이용해서 입력하고, 전체를 출력하는 프로그램을 작성하시오.
CREATE OR REPLACE PROCEDURE DEPT_INSERT(
    DEPT_NO IN DEPT02.DEPARTMENT_ID%TYPE,
    DEPT_NAME IN DEPT02.DEPARTMENT_NAME%TYPE,
    DEPT_MANAGER IN DEPT02.MANAGER_ID%TYPE,
    DEPT_LOCATION IN DEPT02.LOCATION_ID%TYPE)
IS
BEGIN
    INSERT INTO DEPT02 VALUES(DEPT_NO,DEPT_NAME,DEPT_MANAGER,DEPT_LOCATION);
    COMMIT;
    FOR VDEPT IN (SELECT * FROM DEPT02) LOOP
        DBMS_OUTPUT.PUT_LINE('ID = '||VDEPT.DEPARTMENT_ID||'NAME = '||VDEPT.DEPARTMENT_NAME);
    END LOOP;
END;
/

EXECUTE DEPT_INSERT(290,'IT_DEV',NULL,3000);

SELECT * FROM DEPT02;
-- DEPT01 프로시저를 이용해서 새로우는 부서 내용을 입력하고자 한다.
-- 없는 부서이면 INSERT를 하고, 있는 부서이면 UPDATE를 하고, 그리고 해당된 부서를 출력하시오.
CREATE OR REPLACE PROCEDURE DEPT_INSERT_UPDATE(
    DEPT_NO IN DEPT02.DEPARTMENT_ID%TYPE,
    DEPT_NAME IN DEPT02.DEPARTMENT_NAME%TYPE,
    DEPT_MANAGER IN DEPT02.MANAGER_ID%TYPE,
    DEPT_LOCATION IN DEPT02.LOCATION_ID%TYPE)
IS
    VCOUNT NUMBER;
BEGIN
    SELECT COUNT(*) INTO VCOUNT FROM DEPT02 WHERE DEPARTMENT_ID = DEPT_NO;
    IF VCOUNT = 0 THEN
        INSERT INTO DEPT02 VALUES(DEPT_NO,DEPT_NAME,DEPT_MANAGER_ID,DEPT_LOCATION);
    ELSE
        UPDATE DEPT02
        SET DEPARTMENT_NAME = DEPT_NAME, MANAGER_ID = DEPT_MANAGER_ID, LOCATION_ID = DEPT_LOCATION
        WHERE DEPARTMENT_ID = DEPT_NO;
    END IF;
    COMMIT;
    
    INSERT INTO DEPT02 VALUES(DEPT_NO,DEPT_NAME,DEPT_MANAGER,DEPT_LOCATION);
    COMMIT;
    FOR VDEPT IN (SELECT * FROM DEPT02) LOOP
        DBMS_OUTPUT.PUT_LINE('ID = '||VDEPT.DEPARTMENT_ID||'NAME = '||VDEPT.DEPARTMENT_NAME||
        'MANAGER = '||VDEPT.MANAGER_ID||'LOCATION = '||VDEPT.LACATION_ID);
    END LOOP;
END;
/
SELECT * FROM DEPT02;
EXECUTE DEPT_INSERT(300, 'IT_DES', NULL, 4000);
EXECUTE DEPT_INSERT_UPDATE(300, 'IT_DES', NULL, 4000);
-- EMPLOYEE에서 해당아이디를 입력하면. 이름,월급,근무 내용을 리턴하는 프로시저 작성하시오.(OUT MODE)
CREATE OR REPLACE PROCEDURE DEPT_OUTMODE(
    DEPT_NO IN DEPT02.DEPARTMENT_ID%TYPE,
    DEPT_NAME OUT DEPT02.DEPARTMENT_NAME%TYPE,
    DEPT_MANAGER_ID OUT DEPT02.MANAGER_ID%TYPE,
    DEPT_LOCATION OUT DEPT02.LOCATION_ID%TYPE)
IS
BEGIN
    SELECT DEPARTMENT_NAME, MANAGER_ID,LOCATION_ID INTO DEPT_NAME,DEPT_MANAGER_ID,DEPT_LOCATION
    FROM DEPT02 WHERE DEPARTMENT_ID = DEPT_NO;
END;
/

DECLARE
    VEMP DEPT02%ROWTYPE;
BEGIN
    DEPT_OUTMODE(20,VEMP.DEPARTMENT_NAME,VEMP.MANAGER_ID,VEMP.LOCATION_ID);
    DBMS_OUTPUT.PUT_LINE('NAME = '||VEMP.DEPARTMENT_NAME||
        'MANAGER = '||VEMP.MANAGER_ID||'LOCATION = '||VEMP.LOCATION_ID);
END;
/

SELECT * FROM DEPT02;

-- 다른 방법으로 출력
VARIABLE NAME VARCHAR2(20);
VARIABLE MANAGER NUMBER;
VARIABLE LOCATION NUMBER;
EXECUTE DEPT_OUTMODE(20,:NAME,:MANAGER,:LOCATION);
PRINT NAME
PRINT MANAGER
PRINT LOCATION;

-- IN OUT MODE 테스트하기 (됨)
CREATE OR REPLACE PROCEDURE PROC_INOUTMODE(V_SAL IN OUT VARCHAR2)
IS
BEGIN
    V_SAL := '$' || SUBSTR(V_SAL,-9,-3)||','||SUBSTR(V_SAL,-6,-3)||'0,'||SUBSTR(V_SAL, -3, 3);
END PROC_INOUTMODE;
/
DECLARE
    VEMP DEPT02%ROWTYPE;
BEGIN
    DEPT_OUTMODE(20,VEMP.DEPARTMENT_NAME,VEMP.MANAGER_ID,VEMP.LOCATION_ID);
    DBMS_OUTPUT.PUT_LINE('NAME = '||VEMP.DEPARTMENT_NAME||
        'MANAGER = '||VEMP.MANAGER_ID||'LOCATION = '||VEMP.LOCATION_ID);
END;
/
--트리거에서 꼭 기억해야 될 것
--INSERT 입력된 컬럼값은 : NEW,
--DELETE 삭제되는 컬럼: OLD,
--UPDATE 변경전 컬럼: OLD, 수정할 새로운 데이터값: NEW

SELECT * FROM EMP02;
CREATE TABLE EMP02(
    EMPNO NUMBER(4)PRIMARY KEY,
    ENAME VARCHAR2(20),
    JOB VARCHAR2(50)
);
DESC EMP02;
--TRIGGER 설정 EMP02 테이블에 INSERT가 발생하면 입력되었다는 메세지를 출력하시오.
CREATE OR REPLACE TRIGGER EMP02_TRG01
AFTER INSERT ON EMP02
BEGIN
    DBMS_OUTPUT.PUT_LINE('신입사원이 입사했습니다');
END;
/

INSERT INTO EMP02 VALUES(10,'개발부','연구원');
SELECT * FROM EMP02;
-- EMP01에 신입사원이 등록이 되면,SAL01 신입사원 사원번호, 기본월급 2,000,000 TRIGGER 통해서 입력되도록 프로그램을 작성하라.
-- SAL01.SALNO SEQUENCE NUMBER 이용해서 자동으로 증가해서 등록하도록 프로그램할 것
DROP TRIGGER EMP01_TRG02;
CREATE OR REPLACE TRIGGER EMP01_TRG02
AFTER INSERT ON EMP01
FOR EACH ROW
BEGIN
    INSERT INTO SAL01 VALUES(SAL01_SEQ.NEXTVAL, 2000000 ,:NEW.EMPLOYEE_ID);
    DBMS_OUTPUT.PUT_LINE('신입사원이 입사해서 봉급테이블에 새로 등록했습니다.');
END;
/

CREATE TABLE SAL01(
    SALNO NUMBER(4),
    SAL NUMBER,
    EMPNO NUMBER(4),
    CONSTRAINT SAL01_PK PRIMARY KEY(SALNO),
    CONSTRAINT SAL01_PK FOREIGN KEY(EMPNO) REFERENCES EMP01(EMPLOYEE_ID)
);


DROP SEQUENCE SAL01_SEQ;
CREATE SEQUENCE SAL01_SEQ
START WITH 1
INCREMENT BY 1
MINVALUE 1
MAXVALUE 100
NOCYCLE
CACHE 2;

SELECT * FROM EMP01;
INSERT INTO EMP01 VALUES(300,'SUE','95/08/12',2000,'YUN','YSH',01029433814,'IT',NULL,124,40);
INSERT INTO EMP01 VALUES(301,'GIL','96/05/16',2000,'HONG','HGD',01029433815,'IT',NULL,124,40);
SELECT * FROM SAL01;
-- EMP01 300,301 사원번호를 제거하면 SAL01에도 삭제가 진행이 되도록 트리거 프로그램을 작성하시오.

CREATE OR REPLACE TRIGGER EMP01_TRG03
AFTER DELETE ON EMP01
FOR EACH ROW
BEGIN
    DELETE FROM SAL01 WHERE EMPNO = OLD.EMPLOYEE_ID;
    DBMS_OUTPUT.PUT_LINE(:OLD.EMPLOYEE_ID||'신입사원이 입사해서 봉급테이블에서 삭제되었습니다');
END;
/
SELECT * FROM SAL01;
DELETE FROM EMP01 WHERE EMPLOYEE_ID = 301;

SELECT * FROM USER_CONS_COLUMNS WHERE TABLE_NAME = 'EMP01';
ALTER TABLE EMP01
ADD CONSTRAINT EMP01_PK PRIMARY KEY(EMPLOYEE_ID);

-- FUNCTION 프로그램 작성 / 부서번호 값을 입력하면 DEPT01 부서번호를 참조해서 부서명을 리턴해주는 함수를 작성하시오.
-- 해당된 부서번호가 없다면 '해당 부서 번호가 없음' 리턴해주시오.
CREATE OR REPLACE FUNCTION GET_DEPART_NAME(VDEPT_NO IN EMPLOYEES.DEPARTMENT_ID%TYPE) RETURN VARCHAR2
IS
    VCOUNT NUMBER := 0;
    VDEPARTMENT_NAME VARCHAR2(100);
BEGIN
    SELECT COUNT(*) INTO VCOUNT FROM DEPARTMENTS WHERE DEPARTMENT_ID = VDEPT_NO;
    IF VCOUNT = 0 THEN
        VDEPARTMENT_NAME := '해당부서없음';
    ELSE
        SELECT DEPARTMENT_NAME INTO VDEPARTMENT_NAME FROM DEPARTMENTS WHERE DEPARTMENT_ID = VDEPT_NO;
    END IF;
    RETURN VDEPARTMENT_NAME;
END;
/

SELECT FIRST_NAME,JOB_ID,SALARY,DEPARTMENT_ID GET_DEPART_NAME(DEPARTMNET_ID) AS 부서명 
FROM EMPLOYEES WHERE UPPER(FIRST_NAME) = 'STEVEN';

SELECT GET_DEPART_NAME(300) AS 부서명  FROM DUAL;
VARIABLE VDNAME VARCHAR2;
EXECUTE :VDNAME := GET_DEPARTMENT_NAME(20);
PRINT VDNAME;

-- 부서번호를 함수매개변수로 등록하여 해당부서의 평균 급여를 리턴하는 함수를 작성하시오.
CREATE OR REPLACE FUNCTION GET_AVG_SALARY(VDEPT_NO IN EMPLOYEES.DEPARTMENT_ID%TYPE) RETURN VARCHAR2
IS
    VAVG_SALARY VARCHAR2(100);
BEGIN
    SELECT TO_CHAR(AVG(SALARY),'999,999,999') INTO VAVG_SALARY FROM DEPARTMENTS WHERE DEPARTMENT_ID = VDEPT_NO;
    RETURN VAVG_SALARY;
    
    EXCEPTION
        WHEN DO_DATA_FOUND THEN
        VAVG_SALARY := '해당부서없음';
        RETURN VAVG_SALARY;
END;
/

SELECT GET_AVG_SALARY(20)FROM DUAL;
SELECT FIRST_NAME,JOB_ID,SALARY,DEPARTMENT_ID, GET_DEPART_NAME(DEPARTMENT_ID) AS 부서명
    GET_AVG_SALARY(DEPARTMENT_ID) AS 부서평균월급
FROM EMPLOYEES WHERE UPPER(FIRST_NAME) = 'STEVEN';

--내림차순정렬된 순위 설정하기 RANK(),DENSE_RANK()
SELECT ROWNUM, FIRST_NAME,SALARY FROM EMPLOYEES ORDER BY SALARY DESC;
SELECT ROWNUM, FIRST_NAME,SALARY FROM (SELECT FIRST_NAME,SALARY FROM EMPLOYEES ORDER BY SALARY DESC)
WHERE ROWNUM < 10;
SELECT FIRST_NAME,SALARY,RANK() OVER(ORDER BY SALARY DESC), DENSE_RANK() OVER(ORDER BY SALARY DESC)
FROM EMPLOYEES ORDER BY SALARY DESC;

--내림차순정렬된 두 컬럼을 기준으로 순위 결정하기
SELECT DEPARTMENT_ID
    , FIRST_NAME
    , SALARY
    , COMMISSION_PCT
    , RANK() OVER (PARTITION BY DEPARTMENT_ID ORDER BY SALARY DESC,COMMISSION_PCT DESC)RANK
    FROM EMP01
    ORDER BY DEPARTMENT_ID,SALARY DESC,COMMISSION_PCT DESC;

SELECT DEPARTMENT_ID
    , FIRST_NAME
    , SALARY
    , MIN(SALARY) KEEP(DENSE_RANK FIRST ORDER BY SALARY) OVER(PARTITION BY DEPARTMENT_ID) SAL_MIN
    , MAX(SALARY) KEEP(DENSE_RANK FIRST ORDER BY SALARY) OVER(PARTITION BY DEPARTMENT_ID) SAL_MAX
    FROM EMP01
    ORDER BY DEPARTMENT_ID,SALARY DESC;
-- 페이징기법 입사한 날짜별로 정렬을 하되 한 페이지당 10개씩 보여준다. 4페이지를 보여주세요.
SELECT * FROM EMPLOYEES;

SELECT * FROM EMPLOYEES E ORDER BY HIRE_DATE ASC WHERE ROWNUM BETWEEN 31 AND 40;
SELECT * FROM (SELECT ROWNUM AS RNUM,E.* FROM EMPLOYEES E ORDER BY FIRST_NAME ASC) WHERE RNUM BETWEEN 31 AND 40;
SELECT * FROM (SELECT ROWNUM AS RNUM,E.* FROM EMPLOYEES E WHERE ROWNUM <=40 ORDER BY FIRST_NAME ASC) 
WHERE RNUM >= 31;