--DATE DICTIONARY(오라클에서 관리한다)
SELECT * FROM USER_TABLES;
SELECT * FROM USER_CONSTRAINTS;
SELECT * FROM USER_CONS_COLUMNS WHERE TABLE_NAME = 'EMPLOYEES';
SELECT * FROM USER_VIEWS;
--가상뷰 내용 확인하기
SELECT TEXT FROM USER_VIEWS WHERE VIEW_NAME = 'VIEW_EMP01';
SELECT * FROM EMP01;
INSERT INTO EMP01
SELECT EMPLOYEE_ID,FIRST_NAME, JOB_ID, DEPARTMENT_ID FROM EMPLOYEES WHERE EMPLOYEE_ID = 100;
CREATE OR REPLACE VIEW VIEW_EMP01
AS
SELECT * FROM EMP01;
SELECT * FROM VIEW_EMP01;
-- 가상뷰에 데이터를 입력
INSERT INTO VIEW_EMP01 VALUES (200,'YSH','IT DEV','80');
SELECT * FROM EMP01;
DELETE FROM VIEW_EMP01 WHERE EMPNO = 200;
--가상뷰 VIEW_SALARY 실제테이블(부서별 총월급합계,전체평균금액,인원수)
CREATE OR REPLACE VIEW VIEW_SALARY
AS
SELECT DEPARTMENT_ID, SUM(SALARY) TOTAL_SALARY,ROUND(AVG(SALARY),1) AVG_SALARY, COUNT(*) TOTAL_COUNT
FROM EMPLOYEES GROUP BY DEPARTMENT_ID ORDER BY DEPARTMENT_ID ASC;

SELECT DEPARTMENT_ID, SUM(SALARY) TOTAL_SALARY,ROUND(AVG(SALARY),1) AVG_SALARY, COUNT(*) TOTAL_COUNT
FROM EMPLOYEES GROUP BY DEPARTMENT_ID ORDER BY DEPARTMENT_ID ASC;

SELECT * FROM VIEW_SALARY;
SELECT * FROM VIEW_SALARY ORDER BY TOTAL_COUNT ASC;
-- EMPLYOEES, DEPARTMENTS 두 테이블을 조인(INNER JOIN)해서, 아이디, 이름, 부서아이디,부서명 출력하되. 부서아이디 내림차순 정렬
DROP VIEW VIEW_EMP_DEPT;
CREATE VIEW VIEW_EMP_DEPT
AS
SELECT E.EMPLOYEE_ID, E.FIRST_NAME,E.DEPARTMENT_ID, D.DEPARTMENT_ID FROM EMPLOYEES E, DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID
ORDER BY E.DEPARTMENT_ID DESC;
SELECT * FROM VIEW_EMP_DEPT;
--VIEW FORCE TEST (구조는 만들어진다. 조회,DESC 사용하기 힘들다)
SELECT * FROM EMP15;
CREATE OR REPLACE FORCE VIEW VIEW_NOTABLE
AS
SELECT EMPLOYEE_ID FIRST_NAME, SALARY,DEPARTMENT_ID
FROM EMP15;
SELECT * FROM USER_VIEWS;

SELECT * FROM VIEW_NOTABLE;
DESC VIEW_NOTABLE;
--VIEW WITH CHECK OPTION
SELECT * FROM EMP01;
INSERT INTO EMP01
SELECT EMPLOYEE_ID , FIRST_NAME ,JOB_ID, DEPARTMENT_ID FROM EMPLOYEES WHERE NOT EMPLOYEE_ID IN (100,200);


DESC EMP01;
ALTER TABLE EMP01
MODIFY JOB VARCHAR2(20);

SELECT * FROM VIEW_NOTABLE;
DESC VIEW_NOTABLE;
-- VIEW WITH CHECK OPTION TEST
-- VIEW_CHK 만들고, 20번 부서에서 사원번호,이름,월급,
CREATE OR REPLACE VIEW VIEW_CHK
AS
SELECT EMP_NO, EMP_NAME,EMP_JOB, DEP_ID FROM EMP01 WHERE DEP_ID = 20 WITH CHECK OPTION;
SELECT * FROM EMP01;

SELECT * FROM VIEW_CHK;
UPDATE VIEW_CHK SET DEP_ID = 30
WHERE EMP_NO = 201;

DELETE FROM VIEW_CHK WHERE DEP_ID = 20;
-- VIEW WITH READ ONLY : 기본 테이블에 어떤 칼럼에도 내용을 절대 변경할 수 없도록 설정한다.
-- VIEW_READ 생성하고 EMP01에서 부서 30번 아이디,이름,직급,부서 아이디를 출력하시오.
CREATE OR REPLACE VIEW VIEW_READ
AS
SELECT EMP_ID,EMP_NAME,EMP_JOB,DEP_ID 
FROM EMP01 
WHERE DEP_ID = 30
WITH READ ONLY;
SELECT * FROM VIEW_READ;
UPDATE VIEW_READ SET DEP_ID = 100 WHERE EMP_NO = 115;
--ROWNUM 확인하기 (페이징 기법)
SELECT ROWID,ROWNUM, FIRST_NAME FROM EMPLOYEES WHERE ROWNUM <= 10;

--ROWNUM 고용한 날짜 오래된 순으로 10명만 보여주시오.
SELECT ROWNUM, FIRST_NAME,HIRE_DATE FROM EMPLOYEES WHERE ROWNUM < 10 ORDER BY HIRE_DATE;
SELECT FIRST_NAME,HIRE_DATE FROM EMPLOYEES;
--인라인뷰 (TOP-N)
CREATE OR REPLACE VIEW VIEW_HIREDATE_ASC
AS 
SELECT EMPLOYEE_ID,FIRST_NAME, HIRE_DATE FROM EMPLOYEES ORDER BY HIRE_DATE;

SELECT ROWNUM,FIRST_NAME,HIRE_DATE FROM VIEW_HIREDATE_ASC WHERE ROWNUM <= 10;

SELECT ROWNUM, FIRST_NAME, HIRE_DATE FROM
(SELECT EMPLOYEE_ID, FIRST_NAME,HIRE_DATE FROM EMPLOYEES ORDER BY HIRE_DATE)
WHERE ROWNUM <= 10;

SELECT COALESCE(nullif(1,1),200,300) as data from dual;

-- SEQUENCE 생성하기 EMP_SEQ 생성 시작값 1, 증가치 1, 최대값 무한대, 최소값 1, NOCYCLE, CACHE 2;
CREATE SEQUENCE EMP_SEQ
START WITH 1
INCREMENT BY 1
MINVALUE 1
NOMAXVALUE 
NOCYCLE 
CACHE 2;

DROP TABLE EMP01;
CREATE TABLE EMP01
AS
SELECT EMPLOYEE_ID, FIRST_NAME,HIRE_DATE,SALARY FROM EMPLOYEES WHERE 1 = 0;
SELECT * FROM EMP01;
DESC EMP01;
-- SEQUENCE(AUTO INCREMENT) 사용하여 데이터를 입력하시오.
INSERT INTO EMP01 VALUES(EMP_SEQ.NEXTVAL,'YSH',SYSDATE,40000);
INSERT INTO EMP01 VALUES(EMP_SEQ.NEXTVAL,'GAY',(SYSDATE)-1,30000);
SELECT ROWNUM,EMPLOYEE_ID,FIRST_NAME FROM EMP01;
--SEQUENCE 현재 몇번까지 번호 설정되어있는지 출력.
SELECT EMP_SEQ.CURRVAL FROM DUAL;
--SEQUENCE 생성 DEV_SEQ, 시작값 10, 증가치 10 최소값 0 최대값 20 사이클 NOCYCLE CACHE 2
CREATE SEQUENCE DEV_SEQ
START WITH 10
INCREMENT BY 10
MINVALUE 10
MAXVALUE 30
NOCYCLE
CACHE 2;
DROP TABLE DEPT01;
CREATE TABLE DEP01
AS
SELECT DEPARTMENT_ID,DEPARTMENT_NAME,LOCATION_ID FROM DEPARTMENTS WHERE 1 = 0;
--DEPT01 DEV_SEQ 적용해서 입력을 하는데 오류발생
INSERT INTO DEP01 VALUES(DEV_SEQ.NEXTVAL, '행정',1);
INSERT INTO DEP01 VALUES(DEV_SEQ.NEXTVAL, '서무',2);
INSERT INTO DEP01 VALUES(DEV_SEQ.NEXTVAL, '총무',3);
INSERT INTO DEP01 VALUES(DEV_SEQ.NEXTVAL, '교육',4);
SELECT * FROM DEP01;
--DATA DICTIONARY 참조 SEQUENCES 참조
SELECT * FROM USER_SEQUENCES;
--DEV_SEQ 수정 요청
ALTER SEQUENCE DEV_SEQ
MAXVALUE 100;
--인덱스 설정
DROP TABLE EMP01;
CREATE TABLE EMP01
AS
SELECT * FROM EMPLOYEES;
SELECT * FROM EMP01;
--DATA DICTIONARY(오라클에서 데이터베이스 관련된 정보를 관리하는 테이블)
SELECT * FROM USER_TABLES;
SELECT * FROM USER_CONSTRAINTS;
SELECT * FROM USER_CONS_COLUMNS;
SELECT * FROM USER_IND_COLUMNS WHERE TABLE_NAME = 'EMP01';

SELECT * FROM EMP01 WHERE EMPLOYEE_ID = 200;
SELECT * FROM EMPLOYEES WHERE EMPLOYEE_ID = 200;
--EMP01 EMPLOYEE_ID 인덱스설정
CREATE UNIQUE INDEX IDX_EMP01_EMPLOYEE_ID
ON EMP01(EMPLOYEE_ID);
--PL/SQL
DECLARE
    EMP_ID EMPLOYEES.EMPLOYEE_ID%TYPE; -- 스칼라 변수, 래퍼런스 변수(객체참조변수)
    EMP_NAME EMPLOYEES.FIRST_NAME%TYPE;
BEGIN
    SELECT EMPLOYEE_ID, FIRST_NAME INTO EMP_ID, EMP_NAME FROM EMPLOYEES WHERE MANAGER_ID IS NULL;
    DBMS_OUTPUT.PUT_LINE('당신의 아이디는'|| EMP_ID || '당신의 이름은' || EMP_NAME);
END;
/

-- 테이블 타입정의해서 그것을 활용한다.
-- TYPE YSH TO INTEGER
-- INTEGER NO;
-- YSH NO;
DECLARE
    EMP_ID EMPLOYEES.EMPLOYEE_ID%TYPE; -- 스칼라 변수, 래퍼런스 변수(객체참조변수)
    EMP_NAME EMPLOYEES.FIRST_NAME%TYPE;
BEGIN
    SELECT EMPLOYEE_ID, FIRST_NAME INTO EMP_ID, EMP_NAME FROM EMPLOYEES WHERE MANAGER_ID IS NULL;
    DBMS_OUTPUT.PUT_LINE('당신의 아이디는'|| EMP_ID || '당신의 이름은' || EMP_NAME);
END;
/

DESC EMPLOYEES;
SELECT * FROM EMPLOYEES;
SELECT EMPLOYEE_ID, FIRST_NAME FROM EMPLOYEES WHERE MANAGER_ID IS NULL;

--시험문제 1번
--다음은 직원 테이블에서 사원명,직급코드,보너스 받는 사원 수를 조회하여 직급코드 순으로
--오름차순 정렬하는 구문이다. 이 코드의 결과라
SELECT EMPNAME,JOBCODE,COUNT(*) AS 사원수
FROM EMP
WHERE BONUS != 'NULL'
GROUP BY JOBCODE
ORDER BY JOBCODE;
--를 이렇게 바꿔야 한다.
SELECT * FROM EMPLOYEES;
--다음은 부서별(DEPARTMENT_ID) 오름차순으로 정렬하고,
--부서 아이디(JOB_ID), 부서 평균(AVG(SALARY)),부서 인원수(COUNT(JOB_ID))를 출력하시오.
--단 매니저가 있는 사람(MANAGER_ID가 NULL이 아닌)만 진행하시오.
SELECT DEPARTMENT_ID,FIRST_NAME,ROUND(AVG(SALARY)),SUM(SALARY),COUNT(*) FROM EMPLOYEES
WHERE MANAGER_ID IS NOT NULL
GROUP BY FIRST_NAME, DEPARTMENT_ID
ORDER BY DEPARTMENT_ID;

--시험문제 2번
--다음은 사원명이 'JAMS'인 직원의 직급명을 알아내기 위한 SQL 구문이다.
--결과가 올바르게 나오지 않는다고 할 때 그 원인(30점)과, 해결하기 위한 조치사항을 각각 작성하시오.
SELECT E.ENAME,E.JOBNO,J.JOBNO J.JOB_NAME
FROM EMP E NATURAL JOIN JOB J
WHERE ENAME = 'JAMES';
-- 수정내용
SELECT E.NAME, E.JOBNO,J.JOB_NAME
FROM EMP E, JOBL
WHERE E.JOBNO =J.JOBNO AND E.ENAME = 'JAMES';
--ANSI 버전
SELECT E.NAME, E.JOBNO,J.JOB_NAME
FROM EMP E INNER JOIN JOB J
ON E.JOBNO = J.JOBNO
--USING 버전



-- 테이블 (배열)타입정의해서 그것을 활용한다.(배열) INT[] KOR_ARRAY String[] firstName;
DECLARE
    TYPE FIRST_NAME_TABLE_TYPE IS TABLE OF EMPLOYEES.FIRST_NAME%TYPE INDEX BY BINARY_INTEGER;
    TYPE JOB_ID_TABLE_TYPE IS TABLE OF EMPLOYEES.JOB_ID%TYPE INDEX BY BINARY_INTEGER;
    TYPE EMPLOYEE_ID_TABLE_TYPE IS TABLE OF EMPLOYEES.EMPLOYEE_ID%TYPE INDEX BY BINARY_INTEGER;
    TYPE MANAGER_ID_TABLE_TYPE IS TABLE OF EMPLOYEES.MANAGER_ID%TYPE INDEX BY BINARY_INTEGER;
    --변수 (배열타입을 적용) 정수형배열(1),문자열배열(2개)
    NAME_TABLE FIRST_NAME_TABLE_TYPE;
    JOB_TABLE JOB_ID_TABLE_TYPE;
    EMPNO_TABLE EMPLOYEE_ID_TABLE_TYPE;
    MANAGER_TABLE MANAGER_ID_TABLE_TYPE;
    I BINARY_INTEGER := 0;
BEGIN
    FOR K IN (SELECT FIRST_NAME,JOB_ID,EMPLOYEE_ID,MANAGER_ID FROM EMPLOYEES) LOOP
        I := I + 1;
        NAME_TABLE(I) := K.FIRST_NAME;
        JOB_TABLE(I) := K.JOB_ID;
        EMPNO_TABLE(I) := K.EMPLOYEE_ID;
        MANAGER_TABLE(I) := K.MANAGER_ID;
    END LOOP;
    
    FOR J IN 1..I LOOP
        IF(MANAGER_TABLE(I) = '' OR MANAGER_TABLE(I) IS NULL)THEN
            MANAGER_TABLE(I) := 0;
        END IF;
        DBMS_OUTPUT.PUT_LINE('1. FIRST_NAME ='||NAME_TABLE(J)||' 2. JOB_ID(J) ='||JOB_TABLE(J)||'3. EMP_NO ='||EMPNO_TABLE(J)||'4.MANAGER_ID'||MANAGER_TABLE(J));
    END LOOP;
END;
/
SELECT FIRST_NAME,JOB_ID,EMPLOYEE_ID FROM EMPLOYEES;

--RECORD TYPE 정의 CLASS 멤버변수 선택해서 하나의 타입으로 정의하는 것과 같다.
--ROWTYPE CLASS 모든 멤버변수를 선택해서 하나의 타입으로 정의하는 것과 같다.
DECLARE
    TYPE EMP_RECORD_TYPE IS RECORD(
        EMPLOYEE_ID EMPLOYEES.EMPLOYEE_ID%TYPE,
        FIRST_NAME EMPLOYEES.FIRST_NAME%TYPE,
        JOB_ID EMPLOYEES.JOB_ID%TYPE,
        DEPARTMENT_ID EMPLOYEES.DEPARTMENT_ID%TYPE 
    );
    -- 변수(배열타입을 적용) 정수형배열(1), 문자열배열(2개)
    EMP_RECORD EMP_RECORD_TYPE;
BEGIN
    FOR K IN (SELECT EMPLOYEE_ID,FIRST_NAME,JOB_ID,DEPARTMENT_ID FROM EMPLOYEES) LOOP
        EMP_RECORD.EMPLOYEE_ID := K.EMPLOYEE_ID;
        EMP_RECORD.FIRST_NAME := K.FIRST_NAME;
        EMP_RECORD.JOB_ID := K.JOB_ID;
        EMP_RECORD.DEPARTMENT_ID := K.DEPARTMENT_ID;
        DBMS_OUTPUT.PUT_LINE('1.FIRST_NAME'||EMP_RECORD.FIRST_NAME
        ||'2.EMPLOYEE_ID'||EMP_RECORD.EMPLOYEE_ID
        ||'3.JOB_ID'||EMP_RECORD.JOB_ID
        ||'4.DEPARTMENT_ID'||EMP_RECORD.DEPARTMENT_ID
        );
    END LOOP;
END;
/

-- ROW TYP 처리하기 CLASS 모든 멤버변수를 선택해서 하나의 타입으로 정의하는 것과 같다.
DECLARE
    EMP_RECORD EMPLOYEES%ROWTYPE;
BEGIN
    SELECT * INTO EMP_RECORD FROM EMPLOYEES WHERE UPPER(FIRST_NAME) = 'NEENA';
    DBMS_OUTPUT.PUT_LINE('사원번호 =' || EMP_RECORD.FIRST_NAME);
END;
/
--IF THEN ELSE END IF;
--EMP
DECLARE
    EMP_RECORD EMPLOYEES%ROWTYPE;
    ANNSALARY NUMBER(10,2);
BEGIN

    SELECT * INTO EMP_RECORD FROM EMPLOYEES WHERE UPPER(FIRST_NAME) = 'NEENA';
    IF(EMP_RECORD.COMMISSION_PCT IS NULL) THEN
        ANNSALARY := EMP_RECORD.SALARY * 12;
    ELSE
        ANNSALARY := EMP_RECORD.SALARY * 12 + (EMP_RECORD.SALARY * EMP_RECORD.COMMISSION_PCT);
    END IF;
    DBMS_OUTPUT.PUT_LINE('사원번호 =' || EMP_RECORD.FIRST_NAME|| '연봉=' || ANNSALARY);
END;
/

-- 오라클에서 랜덤값 DBMS_RANDOM.VALUE(10,100) (CASTING)(MATH.RANDOM()*(큰값-1+1)+최소값)
SELECT ROUND(DBMS_RANDOM.VALUE(10,100)) FROM DUAL;
--문자값을 임의의 랜덤값으로 구하기 SELECT DBMS_RANDOM.STRING('A',3)
SELECT DBMS_RANDOM.STRING('A',6)FROM DUAL;
--임의의 부서를 조회해서 첫번째 ROWNUM = 1 월급을 가져와서 출력하고, 1~5000 낮음, 5001 ~ 10000 중간, 10001 ~ 20000 최고, ~ 최상위
DECLARE
    EMP_SALARY EMPLOYEES.SALARY%TYPE;
    EMP_DEPNO EMPLOYEES.DEPARTMENT_ID%TYPE;
BEGIN
    EMP_DEPNO := ROUND(DBMS_RANDOM.VALUE(10,110),-1);-- EX) ROUND(23.513,-1) : 20
    SELECT SALARY INTO EMP_SALARY FROM EMPLOYEES WHERE DEPARTMENT_ID = EMP_DEPNO AND ROWNUM <= 1;
    IF(EMP_SALARY BETWEEN 1 AND 5000) THEN
        DBMS_OUTPUT.PUT_LINE('월급낮음');
    ELSIF (EMP_SALARY BETWEEN 1 AND 5000) THEN
        DBMS_OUTPUT.PUT_LINE('월급낮음');
    ELSIF (EMP_SALARY BETWEEN 5001 AND 10000) THEN
        DBMS_OUTPUT.PUT_LINE('월급중간');
    ELSIF (EMP_SALARY BETWEEN 10001 AND 20000) THEN
        DBMS_OUTPUT.PUT_LINE('월급높음');
    ELSE
        DBMS_OUTPUT.PUT_LINE('최고수준');
    END IF;
    
    EXCEPTION
    WHEN NO_DATA_FOUND THEN DBMS_OUTPUT.PUT_LINE('EMP_DEPARTMNET_ID가 없다');
END;
/
--랜덤으로 단수를 구해서 출력하는 프로그램을 작성하시오.
DECLARE
    DAN NUMBER;
    I NUMBER;
    TOTAL NUMBER;
BEGIN
    --랜덤값(1~21)
    DAN := ROUND(DBMS_RANDOM.VALUE(1,21));
    I := 0;
    --무한 루프
    LOOP
    I := I + 1;
    TOTAL := DAN * I;
    DBMS_OUTPUT.PUT_LINE(DAN|| '*' || I || '' || ' = '|| TOTAL);
    EXIT WHEN (I > 9);
    END LOOP;
END;
/
--CURSOR : ARRAYLIST<DEPARTMENTS> 부서정보를 모두 가져와서 출력하는 프로그램을 작성하시오. (단,CURSOR 사용할 것)
DECLARE
    CURSOR DEPARTMENT_CURSOR IS SELECT * FROM DEPARTMENTS;
    VDEPT DEPARTMENTS%ROWTYPE;
BEGIN
    OPEN DEPARTMENT_CURSOR;
    
    LOOP
    FETCH DEPARTMENT_CURSOR INTO VDEPT.DEPARTMENT_ID,VDEPT.DEPARTMENT_NAME,VDEPT.MANAGER_ID,VDEPT.LOCATION_ID;
    
    EXIT WHEN DEPARTMENT_CURSOR%NOTFOUND;
    DBMS_OUTPUT.PUT_LINE(VDEPT.DEPARTMENT_ID|| ' , ' || VDEPT.DEPARTMENT_NAME
        || ' , ' || VDEPT.MANAGER_ID || ' , ' || VDEPT.LOCATION_ID);
    END LOOP;
    
    CLOSE DEPARTMENT_CURSOR;
END;
/
--CURSOR : ARRAYLIST<DEPARTMENTS> 부서정보를 모두 가져와서 출력하는 프로그램을 작성하시오. (단,CURSOR 사용할 것)
--FOR문을 활용해서 출력하시오.
DECLARE
    CURSOR DEPARTMENT_CURSOR IS SELECT * FROM DEPARTMENTS;
    VDEPT DEPARTMENTS%ROWTYPE;
BEGIN
    FOR VDEPT IN DEPARTMENT_CURSOR LOOP
    DBMS_OUTPUT.PUT_LINE(VDEPT.DEPARTMENT_ID|| ' , ' || VDEPT.DEPARTMENT_NAME
        || ' , ' || VDEPT.MANAGER_ID || ' , ' || VDEPT.LOCATION_ID);
    END LOOP;
END;
/
-- 부서정보를 모두 가져와서 출력하는 프로그램을 작성하시오.
-- FOR문을 활용해서 출력하시오.
DECLARE
    VDEPT DEPARTMENTS%ROWTYPE;
BEGIN
    FOR VDEPT IN (SELECT * FROM DEPARTMENTS) LOOP
    DBMS_OUTPUT.PUT_LINE(VDEPT.DEPARTMENT_ID|| ' , ' || VDEPT.DEPARTMENT_NAME
        || ' , ' || VDEPT.MANAGER_ID || ' , ' || VDEPT.LOCATION_ID);
    END LOOP;
END;
/